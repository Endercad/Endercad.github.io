<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>effective-python | 菜鸟的学习笔记</title><meta name="author" content="Endercad"><meta name="copyright" content="Endercad"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Pythonic思维PEP 8规范《Python Enhancement Proposal #8》又叫PEP 8，是针对Python代码格式而编订的风格指南。PEP 8网址. 应该绝对遵守的规则空白 使用space（空格）来表示缩进，不要用tab 和语法相关的每一层缩进都用4个空格表示 每行的字符数不应超过79 对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常缩进的级别之上再加4个空">
<meta property="og:type" content="article">
<meta property="og:title" content="effective-python">
<meta property="og:url" content="http://example.com/2023/04/07/effective-python/index.html">
<meta property="og:site_name" content="菜鸟的学习笔记">
<meta property="og:description" content="Pythonic思维PEP 8规范《Python Enhancement Proposal #8》又叫PEP 8，是针对Python代码格式而编订的风格指南。PEP 8网址. 应该绝对遵守的规则空白 使用space（空格）来表示缩进，不要用tab 和语法相关的每一层缩进都用4个空格表示 每行的字符数不应超过79 对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常缩进的级别之上再加4个空">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-07T02:21:34.000Z">
<meta property="article:modified_time" content="2023-04-14T14:48:30.237Z">
<meta property="article:author" content="Endercad">
<meta property="article:tag" content="effective python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/07/effective-python/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'effective-python',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-14 22:48:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="菜鸟的学习笔记"><span class="site-name">菜鸟的学习笔记</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">effective-python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-07T02:21:34.000Z" title="发表于 2023-04-07 10:21:34">2023-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-14T14:48:30.237Z" title="更新于 2023-04-14 22:48:30">2023-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="effective-python"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Pythonic思维"><a href="#Pythonic思维" class="headerlink" title="Pythonic思维"></a>Pythonic思维</h1><h2 id="PEP-8规范"><a href="#PEP-8规范" class="headerlink" title="PEP 8规范"></a>PEP 8规范</h2><p>《Python Enhancement Proposal #8》又叫PEP 8，是针对Python代码格式而编订的风格指南。<a target="_blank" rel="noopener" href="http://www.python.org/dev/peps/pep-0008">PEP 8网址</a>.</p>
<h3 id="应该绝对遵守的规则"><a href="#应该绝对遵守的规则" class="headerlink" title="应该绝对遵守的规则"></a>应该绝对遵守的规则</h3><h4 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h4><ul>
<li>使用space（空格）来表示缩进，不要用tab</li>
<li>和语法相关的每一层缩进都用<strong>4个</strong>空格表示</li>
<li>每行的字符数不应超过79</li>
<li>对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常缩进的级别之上<strong>再加4个</strong>空格</li>
<li>文件中的函数于类之间应该用<strong>两个空行</strong>隔开</li>
<li>在同一个类中，各方法之间应该用<strong>一个空行</strong>隔开</li>
<li>在使用下标获取列表元素、调用函数或给关键字参数赋值的时候，不要在两旁添加空格</li>
<li>为变量赋值的时候，赋值符号的<strong>左侧和右侧应该写上一个空格</strong></li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li><strong>函数、变量及属性</strong>应该用<strong>小写字母</strong>来拼写，各单词之间以下划线相连，例如，lowercase_underscore</li>
<li>受保护的实例属性，应该以单个下划线开头,例如，_leading_underscore</li>
<li>私有的实例属性，应该以两个下划线开头，例如，__double_leading_underscore</li>
<li>类与异常，应该以每个单词首字母均大写的形式来命名，例如，CapitalizedWorld</li>
<li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线相连，例如，ALL_CAPS</li>
<li>类中的实例方法（instance method），应该把首个参数命名为self，以表示该对象自身。</li>
<li>类方法（class method）的首个参数，应该命名为cls，以表示该类自身</li>
</ul>
<h4 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h4><ul>
<li>采用内联形式的否定词，而不要把否定词放在整个表达式的前面，例如，应该写 if a is not b 而不是 if not a is b.</li>
<li>不要通过检测长度的办法(如 if len(somelist) &#x3D;&#x3D; 0)来判断some list是否为[]或’’等空值，而是应该采用if not somelist 这种写法来判断，空值将自动评估为False</li>
<li>检测somelist是否为[1]或’hi’等非空值时，也应该如此，if somelist语句默认会把非空值判断为True</li>
<li>不要编写单行的if语句、for循环、while循环及except复合语句，而是应该把这些语句分成多行来书写，以示清晰</li>
<li>如果表达式一行写不下，可以用括号将其括起来，而且要适当地添加换行与缩进以便于阅读。</li>
<li>多行的表达式，应该用括号括起来，而不要用\符号续行。</li>
</ul>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><ul>
<li>import语句总是应该放在文件开头</li>
<li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称，例如，引入bar包中的foo模块时，应该完整地写出<code>from bar import foo</code> 而不应该简写为<code>import foo</code></li>
<li>如果一定要以相对名称来编写import语句，那就采用明确的写法:<code>from . import foo</code></li>
<li>文件中的那些import 语句应该按顺序分成三个部分，分别表示标准库模块、第三方模块以及自用模块。在每一部分之中，各import语句应该按模块的字母顺序来排列</li>
</ul>
<h2 id="用支持插值的f-string取代C风格的格式字符串与str-format方法"><a href="#用支持插值的f-string取代C风格的格式字符串与str-format方法" class="headerlink" title="用支持插值的f-string取代C风格的格式字符串与str.format方法"></a>用支持插值的f-string取代C风格的格式字符串与str.format方法</h2><p>格式化（formatting）是指把数据填写到预先定义的文本模板里面，形成一条用户可读的消息，并把这条消息保存成字符串的过程。</p>
<h3 id="格式化操作符"><a href="#格式化操作符" class="headerlink" title="%格式化操作符"></a>%格式化操作符</h3><p>Python里面最常用的字符串格式化方式是采用%格式化操作符。这个操作符左边的文本模板叫作格式字符串（format string），我们可以在操作符右边写上某个值或者由多个值所构成的元组（tuple），用来替换格式字符串里的相关符号。例如，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;world&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello %s,hello %s&#x27;</span> % (a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment">## output:hello world,hello python</span></span><br></pre></td></tr></table></figure>

<p>格式字符串里面可以出现%d这样的格式说明符，这些说明符的意思是，%右边的对应数值会以这样的格式来替换这一部分内容。格式说明符的写法来自C语言的printf函数，Python语言以及其他一些编程语言，都依照那套写法来规定自己的格式字符串。所以，常见的printf选项都可以当成Python的格式说明符来用，例如%s、%x、%f等，此外还可以控制小数点的位值，并指定填充与对齐方式。</p>
<p>C风格的格式字符串，在Python里有四个缺点。</p>
<ul>
<li>第一个缺点是，如果%右侧那个元组里面的值在类型或顺序上有变化，那么程序可能会因为转换类型时发生不兼容问题而出现错误。</li>
<li>第二个缺点是，在填充模板之前，经常要先对准备填写进去的这个值稍微做一些处理，但这样一来，整个表达式可能就会写得很长，让人觉得比较混乱。</li>
<li>第三个缺点是，如果想用同一个值来填充格式字符串里的多个位置，那么必须在%操作符右侧的元组中相应地多次重复该值。</li>
<li>第四个缺点是，把dict写到格式化表达式里面会让代码变多。每个键都至少要写两次：一次是在格式说明符中，还有一次是在字典中作为键，另外，定义字典的时候，可能还要专门用一个变量来表示这个键所对应的值，而且这个变量的名称或许也和键名相同，这样算下来就是三次了。</li>
</ul>
<h3 id="内置的format函数与str类的format方法"><a href="#内置的format函数与str类的format方法" class="headerlink" title="内置的format函数与str类的format方法"></a>内置的format函数与str类的format方法</h3><p>Python 3添加了高级字符串格式化（advanced string formatting）机制，它的表达能力比老式C风格的格式字符串要强，且不再使用%操作符。我们针对需要调整格式的这个Python值，调用内置的format函数，并把这个值所应具备的格式也传给该函数，即可实现格式化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1234.5678</span></span><br><span class="line">formatted=<span class="built_in">format</span>(a,<span class="string">&#x27;,.2f&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(formatted)</span><br><span class="line"><span class="comment">#output:1,234.57</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">formatted=<span class="built_in">format</span>(b,<span class="string">&#x27;^20s&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>,formatted,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="comment">#output:*        hello         *</span></span><br></pre></td></tr></table></figure>

<p>在传给format函数的格式里面，逗号表示显示千位分隔符，^表示居中对齐。</p>
<p>如果str类型的字符串里面有许多值都需要调整格式，则可以调用str的新format方法。该方法不使用%d这样的C风格格式说明符。而是把格式有待调整的那些位置在字符串里面先用{}代替，然后按从左到右的顺序，把需要填写到那些位置的值传给format方法，使这些值依次出现在字符串中的相应位置。</p>
<p>可以在{}里写个冒号，然后把格式说明符写在冒号的右边，用以规定format方法所接收的这个值应该按照怎样的格式来调整.调用str.format方法的时候，也可以给str的{}里面写上数字，用来指代format方法在这个位置所接收到的参数值位置索引。同一个位置索引可以出现在str的多个{}里面，这些{}指代的都是format方法在对应位置所收到的值。</p>
<p>但是str.format无法解决上面所说的第二个与第四个缺点</p>
<h3 id="插值格式字符串"><a href="#插值格式字符串" class="headerlink" title="插值格式字符串"></a>插值格式字符串</h3><p>Python 3.6添加了一种新的特性，叫作插值格式字符串（interpolated format string，简称f-string），可以解决上面提到的所有问题。新语法特性要求在格式字符串的前面加字母f作为前缀，这跟字母b与字母r的用法类似，也就是分别表示字节形式的字符串与原始的（或者说未经转义的）字符串的前缀。</p>
<p>可以直接在f-string的{}里面引用当前Python范围内的所有名称，进而达到简化的目的。彻底解决了上文提到的第四个缺点，也就是键名重复导致的程序冗余问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key=<span class="string">&#x27;var&#x27;</span></span><br><span class="line">val=<span class="number">123.4</span></span><br><span class="line">formatted=<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;val&#125;</span>&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(formatted)</span><br><span class="line"><span class="comment">#output var=123.4</span></span><br></pre></td></tr></table></figure>

<p>str.format方法所支持的那套迷你语言，也就是在{}内的冒号右侧所采用的那套规则，现在也可以用到f-string里面，而且还可以像早前使用str.format时那样，通过!符号把值转化成Unicode及repr形式的字符串。</p>
<h2 id="用辅助函数取代复杂的表达式"><a href="#用辅助函数取代复杂的表达式" class="headerlink" title="用辅助函数取代复杂的表达式"></a>用辅助函数取代复杂的表达式</h2><p>当表达式过长的时候，可以用if&#x2F;else结构实现三元的条件表达式，但这种写法不如完整的多行if&#x2F;else结构清晰，如果要反复使用这套逻辑，最好的方法是写成辅助函数</p>
<h2 id="尽量用enumerate取代range"><a href="#尽量用enumerate取代range" class="headerlink" title="尽量用enumerate取代range"></a>尽量用enumerate取代range</h2><p>Python内置的range函数适合用来迭代一系列整数。如果要迭代的是某种数据结构，例如字符串列表，那么可以直接在这个序列上面迭代，用不着专门通过range设定一个取值范围，然后把这个范围里的每个整数值，依次当成下标来访问列表中的元素。</p>
<p>当有时候需要知道元素在list中的位置时，为了实现这样的功能，可以使用range实现。但这样的方法需要知道列表的长度，步骤太多。</p>
<p>Python有个内置的函数，叫作enumerate，它可以解决刚才的问题。enumerate能够把任何一种迭代器（iterator）封装成惰性生成器。这样的话，每次循环的时候，它只需要从iterator里面获取下一个值就行了，同时还会给出本轮循环的序号，即生成器每次产生的一对输出值。可以通过enumerate的第二个参数指定起始序号，这样就不用在每次打印的时候去调整了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">snacks=[<span class="string">&#x27;bacon&#x27;</span>,<span class="string">&#x27;hamburger&#x27;</span>,<span class="string">&#x27;ice-cream&#x27;</span>]</span><br><span class="line">it=<span class="built_in">enumerate</span>(snacks,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="comment">## output:</span></span><br><span class="line"><span class="comment"># (1, &#x27;bacon&#x27;)</span></span><br><span class="line"><span class="comment"># (2, &#x27;hamburger&#x27;)</span></span><br><span class="line"><span class="comment"># (3, &#x27;ice-cream&#x27;)</span></span><br></pre></td></tr></table></figure>

<h2 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h2><p>如果两个列表对应位置的元素有着一定的关系，并且需要同时遍历这两个列表，一种方法是使用range对列表长度做迭代</p>
<p>为了把代码写得更清楚，可以用Python内置的zip函数来实现。这个函数能把两个或更多的iterator封装成惰性生成器（lazy generator）。每次循环时，它会分别从这些迭代器里获取各自的下一个元素，并把这些值放在一个元组里面。而这个元组可以拆分到for语句里的那些变量之中。这样写出来的代码，比通过下标访问多个列表的那种代码要清晰得多。</p>
<p>zip每次只从它封装的那些迭代器里面各自取出一个元素，所以即便源列表很长，程序也不会因为占用内存过多而崩溃。</p>
<p>但是，如果zip中列表的长度不一致，zip在处理完其中任何一个迭代器之后就不会再往下，循环的次数实际上等于最短的那个列表所具备的长度。</p>
<h2 id="用赋值表达式"><a href="#用赋值表达式" class="headerlink" title="用赋值表达式"></a>用赋值表达式</h2><p>赋值表达式（assignment expression）是Python 3.8新引入的语法，它会用到海象操作符（walrus operator）。这种写法可以解决某些持续已久的代码重复问题。a &#x3D; b是一条普通的赋值语句，读作a equals b，而<strong>a :&#x3D; b则是赋值表达式</strong>，读作a walrus b。这个符号为什么叫walrus呢？因为把:&#x3D;顺时针旋转90º之后，冒号就是海象的一双眼睛，等号就是它的一对獠牙。</p>
<p>赋值表达式可以再普通的赋值语句无法应用的场合使用，例如在条件表达式的if语句中，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 常规写法</span></span><br><span class="line">count = get_lemon_num()</span><br><span class="line"><span class="keyword">if</span> count:</span><br><span class="line">    make_lemonade(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    out_of_stock()</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 赋值表达式写法</span></span><br><span class="line"><span class="keyword">if</span> count := get_lemon_num():</span><br><span class="line">    make_lemonade(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    out_of_stock()</span><br></pre></td></tr></table></figure>

<p>在python中实现switch&#x2F;case的一种方法是嵌套if&#x2F;elif&#x2F;else结构。在使用海象操作符时，可以轻松模拟很接近switch&#x2F;case的方案</p>
<h1 id="列表与字典"><a href="#列表与字典" class="headerlink" title="列表与字典"></a>列表与字典</h1><h2 id="通过带星号的unpacking操作来捕获多个元素，不要用切片"><a href="#通过带星号的unpacking操作来捕获多个元素，不要用切片" class="headerlink" title="通过带星号的unpacking操作来捕获多个元素，不要用切片"></a>通过带星号的unpacking操作来捕获多个元素，不要用切片</h2><p>带星号的表达式也是一种unpacking操作，它可以把无法由普通变量接收的那些元素全部囊括进去。带星号的表达式可以出现在任意位置，所以它能够捕获序列中的任何一段元素。但是在使用这种写法时，至少要有一个普通的接收变量与它搭配，另外，对于单层结构来说，同一级里至多只能出现一次带星号的unpacking。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">smallest,second_small,*others=nums</span><br><span class="line">smallest,second_small,others</span><br><span class="line"><span class="comment">#output:(1, 2, [3, 4, 5, 6, 7])</span></span><br><span class="line">smallest,*others,biggest=nums</span><br><span class="line">smallest,others,biggest</span><br><span class="line"><span class="comment">#output:(1, [2, 3, 4, 5, 6], 7)</span></span><br></pre></td></tr></table></figure>

<h2 id="用sort方法的key参数来表示复杂的排序逻辑"><a href="#用sort方法的key参数来表示复杂的排序逻辑" class="headerlink" title="用sort方法的key参数来表示复杂的排序逻辑"></a>用sort方法的key参数来表示复杂的排序逻辑</h2><p>凡是具备自然顺序的内置类型几乎都可以用sort方法排列，例如字符串、浮点数等。但是对于对象，这些排序标准通常是针对对象中的某个属性（attribute）。我们可以把这样的排序逻辑定义成函数，然后将这个函数传给sort方法的key参数。key所表示的函数本身应该带有一个参数，这个参数指代列表中有待排序的对象，函数返回的应该是个可比较的值（也就是具备自然顺序的值），以便sort方法以该值为标准给这些对象排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,weigth</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.weight=weigth</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Tool(<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;self.weight&#125;</span>)&#x27;</span></span><br><span class="line">tools=[</span><br><span class="line">    Tool(<span class="string">&#x27;level&#x27;</span>,<span class="number">3.5</span>),</span><br><span class="line">    Tool(<span class="string">&#x27;hammer&#x27;</span>,<span class="number">1.25</span>),</span><br><span class="line">    Tool(<span class="string">&#x27;screwdriver&#x27;</span>,<span class="number">0.5</span>),</span><br><span class="line">    Tool(<span class="string">&#x27;chisel&#x27;</span>,<span class="number">0.25</span>)</span><br><span class="line">]</span><br><span class="line">tools.sort(key=<span class="keyword">lambda</span> x:x.name)</span><br><span class="line">tools</span><br><span class="line"><span class="comment">#output:[Tool(chisel,0.25), Tool(hammer,1.25), Tool(level,3.5), Tool(screwdriver,0.5)]</span></span><br></pre></td></tr></table></figure>

<p>在编写传给key参数的lambda函数时，可以像刚才那样返回对象的某个属性，如果对象是序列、元组或字典，那么还可以返回其中的某个元素。其实，只要是有效的表达式，都可以充当lambda函数的返回值。sort方法可以指定reverse参数实现降序排序</p>
<h2 id="用get处理键不在字典中的情况，不要使用in与KeyError"><a href="#用get处理键不在字典中的情况，不要使用in与KeyError" class="headerlink" title="用get处理键不在字典中的情况，不要使用in与KeyError"></a>用get处理键不在字典中的情况，不要使用in与KeyError</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fruits=&#123;<span class="string">&#x27;apple&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;orange&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># 判断是否含有apple这个属性</span></span><br><span class="line">key=<span class="string">&#x27;apple&#x27;</span></span><br><span class="line"><span class="comment"># 使用in来判断</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> fruits:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># 利用keyError异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    count=fruits[key]</span><br><span class="line"><span class="keyword">except</span> keyError:</span><br><span class="line">    ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>获取字典中存在的键，或给字典中不存在的键指定默认值，这两种操作非常常见。所以，Python内置的字典（dict）类型提供了get方法，可以通过第一个参数指定自己想查的键，并通过第二个参数指定这个键不存在时应返回的默认值。这种写法也只需要在查询键值时访问一次键名，然后做一次赋值操作，但要比刚才那种通过KeyError实现的方案简单得多。</p>
<p>dict类型提供了setdefault方法，这个方法会查询字典里有没有这个键，如果有，就返回对应的值；如果没有，就先把用户提供的默认值跟这个键关联起来并插入字典，然后返回这个值.</p>
<p>还有个关键的地方要注意：在字典里面没有这个键时，setdefault方法会把默认值直接放到字典里，而不是先给它做副本，然后把副本放到字典中</p>
<h2 id="用defaultdict处理内部状态中缺失的元素，而不要用setdefault"><a href="#用defaultdict处理内部状态中缺失的元素，而不要用setdefault" class="headerlink" title="用defaultdict处理内部状态中缺失的元素，而不要用setdefault"></a>用defaultdict处理内部状态中缺失的元素，而不要用setdefault</h2><p>Python内置的collections模块提供了defaultdict类,它会在键缺失的情况下，自动添加这个键以及键所对应的默认值。当使用defaultdict创建字典时，访问一个不存在的键，会自动添加这个键以及键所对应的默认值。</p>
<h2 id="学会利用-missing-构造依赖键的默认值"><a href="#学会利用-missing-构造依赖键的默认值" class="headerlink" title="学会利用__missing__构造依赖键的默认值"></a>学会利用__missing__构造依赖键的默认值</h2><p>通过继承dict类型并实现<code>__missing__</code>特殊方法可以在字典不存在这个键时执行我们自定义的逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self,key</span>):</span><br><span class="line">        value = open_picture(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">pictures=Picture()</span><br><span class="line">handle=pictures[path]</span><br><span class="line">handle.seek(<span class="number">0</span>)</span><br><span class="line">image_data=handle.read()</span><br></pre></td></tr></table></figure>

<p>访问pictures[path]时，如果pictures字典里没有path这个键，那就会调用__missing__方法。这个方法必须根据key参数创建一份新的默认值，系统会把这个默认值插入字典并返回给调用方。以后再访问pictures[path]，就不会调用__missing__了，因为字典里已经有了对应的键与值</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="不要把函数返回的多个数值拆分到三个以上的变量中"><a href="#不要把函数返回的多个数值拆分到三个以上的变量中" class="headerlink" title="不要把函数返回的多个数值拆分到三个以上的变量中"></a>不要把函数返回的多个数值拆分到三个以上的变量中</h2><p>不应该把函数返回的多个值拆分到三个以上的变量里。一个三元组最多只拆成三个普通变量，或两个普通变量与一个万能变量（带星号的变量）。当然用于接收的变量个数也可以比这更少。假如要拆分的值确实很多，那最好还是定义一个轻便的类或namedtuple，并让函数返回这样的实例。</p>
<h2 id="遇到意外状况时应该抛出异常，不要返回None"><a href="#遇到意外状况时应该抛出异常，不要返回None" class="headerlink" title="遇到意外状况时应该抛出异常，不要返回None"></a>遇到意外状况时应该抛出异常，不要返回None</h2><p>在if语句中，可能会无法明确区分0和None，因此用None表示特殊状况的函数很容易出错，解决这种错误的方法时抛出异常，让调用方去处理。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在表达式中引用某个变量时，Python解释器会按照下面的顺序，在各个作用域（scope）里面查找这个变量，以解析（resolve）这次引用。</p>
<p>1）当前函数的作用域。</p>
<p>2）外围作用域（例如包含当前函数的其他函数所对应的作用域）。</p>
<p>3）包含当前代码的那个模块所对应的作用域（也叫全局作用域，global scope）。</p>
<p>4）内置作用域（built-in scope，也就是包含len与str等函数的那个作用域）。如果这些作用域中都没有定义名称相符的变量，那么程序就抛出NameError异常。</p>
<p>给变量赋值时，要分两种情况处理。如果变量已经定义在当前作用域中，那么直接把新值交给它就行了。如果当前作用域中不存在这个变量，那么即便外围作用域里有同名的变量，Python也还是会把这次的赋值操作当成变量的定义来处理，这会产生一个重要的效果，也就是说，Python会把包含赋值操作的这个函数当成新定义的这个变量的作用域。</p>
<p>Python有一种特殊的写法，可以把闭包里面的数据赋给闭包外面的变量。用nonlocal语句描述变量，就可以让系统在处理针对这个变量的赋值操作时，去外围作用域查找。然而，nonlocal有个限制，就是不能侵入模块级别的作用域（以防污染全局作用域）。例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sort_priority</span>(<span class="params">numbers,group</span>):</span><br><span class="line">    found=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="comment">#如果没有用nonlocal语句，那么在helper函数里的found=True会在这个函数的作用域内定义found变量，不会改变外层的found</span></span><br><span class="line">        <span class="keyword">nonlocal</span> found</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            found=<span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span>(<span class="number">0</span>,x)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>,x)</span><br><span class="line">    numbers.sort(key=helper)</span><br><span class="line">    <span class="keyword">return</span> found</span><br></pre></td></tr></table></figure>

<h2 id="用数量可变的位置参数给函数设计清晰的参数列表"><a href="#用数量可变的位置参数给函数设计清晰的参数列表" class="headerlink" title="用数量可变的位置参数给函数设计清晰的参数列表"></a>用数量可变的位置参数给函数设计清晰的参数列表</h2><p>让函数接受数量可变的位置参数（positional argument），可以把函数设计得更加清晰（这些位置参数通常简称varargs，或者叫作star args，因为我们习惯用*args指代）</p>
<p>Python里，可以给最后一个位置参数加前缀*，这样调用者就只需要提供不带星号的那些参数，然后可以不再指其他参数，也可以继续指定任意数量的位置参数。函数的主体代码不用改，只修改调用代码即可。</p>
<p>如果想把已有序列（例如某列表）里面的元素当成参数传给像log这样的参数个数可变的函数（variadic function），那么可以在传递序列的时采用*操作符。这会让Python把序列中的元素都当成位置参数传给这个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">message,*values</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value_str=<span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;message&#125;</span> :<span class="subst">&#123;value_str&#125;</span>&#x27;</span>)</span><br><span class="line">favorites=[<span class="number">7</span>,<span class="number">33</span>,<span class="number">99</span>]</span><br><span class="line">log(<span class="string">&#x27;Favorite colors&#x27;</span>,*favorites)</span><br></pre></td></tr></table></figure>

<p>接受<em>args参数的函数，适合处理输入值不太多，而且数量可以提前预估的情况。在调用这种函数时，传给</em>args这一部分的应该是许多个字面值或变量名才对。这种机制，主要是为了让代码写起来更方便、读起来更清晰。</p>
<h2 id="用关键字参数来表示可选的行为"><a href="#用关键字参数来表示可选的行为" class="headerlink" title="用关键字参数来表示可选的行为"></a>用关键字参数来表示可选的行为</h2><p>Python函数里面的所有普通参数，除了按位置传递外，还可以按关键字传递。在调用括号内可以把关键字的名称写在&#x3D;左边，把参数值写在右边。</p>
<p>关键字形式与位置形式也可以混用。如果混用，那么位置参数必须出现在关键字参数之前,每个参数只能指定一次，不能既通过位置形式指定，又通过关键字形式指定。否则就会出错。</p>
<p>如果有一份字典，而且字典里面的内容能够用来调用具有相同形参名的函数，那么可以把**运算符加在字典前面，这会让Python把字典里面的键值以关键字参数的形式传给函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remainder</span>(<span class="params">number,divisor</span>):</span><br><span class="line">    <span class="keyword">return</span> number % divisor</span><br><span class="line">my_kwargs=&#123;</span><br><span class="line">    <span class="string">&#x27;number&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;divisor&#x27;</span>:<span class="number">7</span>,</span><br><span class="line">&#125;</span><br><span class="line">remainder(**my_kwargs)</span><br></pre></td></tr></table></figure>

<p>定义函数时，如果想让这个函数接受任意数量的关键字参数，那么可以在参数列表里写上万能形参**kwargs，它会把调用者传进来的参数收集合到一个字典里面稍后处理</p>
<h2 id="用None和docstring来描述默认值会变的参数"><a href="#用None和docstring来描述默认值会变的参数" class="headerlink" title="用None和docstring来描述默认值会变的参数"></a>用None和docstring来描述默认值会变的参数</h2><p>有时，我们想把那种不能够提前固定的值，当作关键字参数的默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">message,when=datetime.now(<span class="params"></span>)</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;when&#125;</span>:<span class="subst">&#123;message&#125;</span>&#x27;</span>)</span><br><span class="line">log(<span class="string">&#x27;Hi there&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">log(<span class="string">&#x27;Hello again&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面这个函数两次输出的时间都相同，因为参数的默认值只会在系统加载这个模块的时候，计算一遍，而不会在每次执行时都重新计算，这通常意味着这些默认值在程序启动后，就已经定下来了。</p>
<p>要想在Python里实现这种效果，惯用的办法是把参数的默认值设为None，同时在docstring文档里面写清楚，这个参数为None时，函数会怎么运作。给函数写实现代码时，要判断该参数是不是None，如果是，就把它改成相应的默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">message,when=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Log a message with a timestamp</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    	message:Message to print</span></span><br><span class="line"><span class="string">    	when:datetime of when the message occurred</span></span><br><span class="line"><span class="string">    		Defaults to the present time</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> when <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        when = datetime.now()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;when&#125;</span>:<span class="subst">&#123;message&#125;</span>&#x27;</span>)</span><br><span class="line">log(<span class="string">&#x27;Hi there&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">log(<span class="string">&#x27;Hello again&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>把参数的默认值写成None还有个重要的意义，就是用来表示那种以后可能由调用者修改内容的默认值（例如某个可变的容器）。</p>
<h2 id="用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"><a href="#用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表" class="headerlink" title="用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"></a>用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</h2><p>对于参数比较复杂的函数，可以声明只能通过关键字指定的参数。在定义函数时，参数列表里的<code>*</code>把参数分成两组，左边是位置参数，右边是只能用关键字指定的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_divison</span>(<span class="params">number,divisor,*,ignore_overfolw=<span class="literal">False</span>,ignore_zero_division=<span class="literal">False</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>有时在定义函数时，不期望调用者采用定义时的名称来指定某参数，可以将其设置为只能按位置传递参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_divison</span>(<span class="params">number,divisor,/,*,ignore_overfolw=<span class="literal">False</span>,ignore_zero_division=<span class="literal">False</span></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>参数列表中的<code>/</code>符号，表示它左边的那些参数只能按位置指定。</p>
<p>在函数的参数列表之中，&#x2F;符号左侧的参数是只能按位置指定的参数，<em>符号右侧的参数则是只能按关键字形式指定的参数。那么，这两个符号如果同时出现在参数列表中，会有什么效果呢？这是个值得注意的问题。这意味着，*<em>这两个符号之间的参数，既可以按位置提供，又可以用关键字形式指定</em></em></p>
<h2 id="用functools-wraps定义函数修饰器"><a href="#用functools-wraps定义函数修饰器" class="headerlink" title="用functools.wraps定义函数修饰器"></a>用functools.wraps定义函数修饰器</h2><p>Python中有一种特殊的写法，可以用修饰器（decorator）来封装某个函数，从而<strong>让程序在执行这个函数之前与执行完这个函数之后，分别运行某些代码</strong>。</p>
<p>这意味着，调用者传给函数的<strong>参数值、函数返回给调用者的值，以及函数抛出的异常，都可以由修饰器访问并修改.能够确保用户以正确的方式使用函数，也能够用来调试程序或实现函数注册功能，此外还有许多用途。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        result=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;args!r&#125;</span>,<span class="subst">&#123;kwargs!r&#125;</span>&#x27;</span></span><br><span class="line">              <span class="string">f&#x27;-&gt; <span class="subst">&#123;result!r&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>定义这样一个修饰器，在实现这个修饰器时，用*args与**kwargs表示受修饰的原函数func所收到的参数</p>
<p>写好之后，我们用@符号把修饰器运用在想要调试的函数上面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> (fibonacci(n-<span class="number">2</span>)+fibonacci(n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>当通过原来的名字调用函数时,执行的是修饰后的函数<code>fibonacci=trace(fibonacci)</code>修饰过的fibonacci函数，会在执行自身的代码前，先执行wrapper里位于func(*args, **kwargs)那一行之前的逻辑；并且在执行完自身的代码后，执行wrapper里位于func(*args, **kwargs)那一行之后的逻辑。本例中，它会在执行完自身的代码之后，打印出这次执行所用的参数与返回值，这样就能看到整个递归栈的情况了。</p>
<p>使用修饰器带来的一个副作用是调用原函数相当于调用wrapper函数，上面的<code>fibonacci</code>表示的实际上是<code>wrapper</code>，这样可能会干扰需要利用<code>introspection</code>机制运作的工具。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(fibonacci)</span><br><span class="line"><span class="comment">#output:&lt;function trace.&lt;locals&gt;.wrapper at 0x0000021B6310DEE0&gt;</span></span><br></pre></td></tr></table></figure>

<p>要想解决这些问题，可以改用functools内置模块之中的<code>wraps</code>辅助函数来实现。<code>wraps</code>本身也是个修饰器，它可以帮助你编写自己的修饰器。把它运用到wrapper函数上面，它就会将重要的元数据（metadata）全都从内部函数复制到外部函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        result=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;args!r&#125;</span>,<span class="subst">&#123;kwargs!r&#125;</span>&#x27;</span></span><br><span class="line">              <span class="string">f&#x27;-&gt; <span class="subst">&#123;result!r&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> (fibonacci(n-<span class="number">2</span>)+fibonacci(n-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:&lt;function fibonacci at 0x0000021B63C32040&gt;</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Endercad</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/07/effective-python/">http://example.com/2023/04/07/effective-python/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">菜鸟的学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/effective-python/">effective python</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/11/el-form%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%BA%8C%E9%80%89%E4%B8%80%E5%BF%85%E5%A1%AB/" title="el-form表单验证二选一必填"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">el-form表单验证二选一必填</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/11/matplotlib%E5%AD%A6%E4%B9%A0/" title="matplotlib学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">matplotlib学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Endercad</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/endercad"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">要比昨天的自己更好</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Pythonic%E6%80%9D%E7%BB%B4"><span class="toc-number">1.</span> <span class="toc-text">Pythonic思维</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PEP-8%E8%A7%84%E8%8C%83"><span class="toc-number">1.1.</span> <span class="toc-text">PEP 8规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E7%BB%9D%E5%AF%B9%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">应该绝对遵守的规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%99%BD"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">空白</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">表达式和语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">引入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%94%AF%E6%8C%81%E6%8F%92%E5%80%BC%E7%9A%84f-string%E5%8F%96%E4%BB%A3C%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Estr-format%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">用支持插值的f-string取代C风格的格式字符串与str.format方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">%格式化操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84format%E5%87%BD%E6%95%B0%E4%B8%8Estr%E7%B1%BB%E7%9A%84format%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">内置的format函数与str类的format方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.</span> <span class="toc-text">插值格式字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">用辅助函数取代复杂的表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E7%94%A8enumerate%E5%8F%96%E4%BB%A3range"><span class="toc-number">1.4.</span> <span class="toc-text">尽量用enumerate取代range</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8zip%E5%87%BD%E6%95%B0%E5%90%8C%E6%97%B6%E9%81%8D%E5%8E%86%E4%B8%A4%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">用zip函数同时遍历两个迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">用赋值表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E4%B8%8E%E5%AD%97%E5%85%B8"><span class="toc-number">2.</span> <span class="toc-text">列表与字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%B8%A6%E6%98%9F%E5%8F%B7%E7%9A%84unpacking%E6%93%8D%E4%BD%9C%E6%9D%A5%E6%8D%95%E8%8E%B7%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8%E5%88%87%E7%89%87"><span class="toc-number">2.1.</span> <span class="toc-text">通过带星号的unpacking操作来捕获多个元素，不要用切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8sort%E6%96%B9%E6%B3%95%E7%9A%84key%E5%8F%82%E6%95%B0%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8E%92%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.</span> <span class="toc-text">用sort方法的key参数来表示复杂的排序逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8get%E5%A4%84%E7%90%86%E9%94%AE%E4%B8%8D%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8in%E4%B8%8EKeyError"><span class="toc-number">2.3.</span> <span class="toc-text">用get处理键不在字典中的情况，不要使用in与KeyError</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8defaultdict%E5%A4%84%E7%90%86%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%A6%81%E7%94%A8setdefault"><span class="toc-number">2.4.</span> <span class="toc-text">用defaultdict处理内部状态中缺失的元素，而不要用setdefault</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%BC%9A%E5%88%A9%E7%94%A8-missing-%E6%9E%84%E9%80%A0%E4%BE%9D%E8%B5%96%E9%94%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">2.5.</span> <span class="toc-text">学会利用__missing__构造依赖键的默认值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E6%8A%8A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%95%B0%E5%80%BC%E6%8B%86%E5%88%86%E5%88%B0%E4%B8%89%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="toc-number">3.1.</span> <span class="toc-text">不要把函数返回的多个数值拆分到三个以上的变量中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E6%84%8F%E5%A4%96%E7%8A%B6%E5%86%B5%E6%97%B6%E5%BA%94%E8%AF%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9ENone"><span class="toc-number">3.2.</span> <span class="toc-text">遇到意外状况时应该抛出异常，不要返回None</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.3.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E7%BB%99%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E6%B8%85%E6%99%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">用数量可变的位置参数给函数设计清晰的参数列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%8F%AF%E9%80%89%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.5.</span> <span class="toc-text">用关键字参数来表示可选的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8None%E5%92%8Cdocstring%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E4%BC%9A%E5%8F%98%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">用None和docstring来描述默认值会变的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%8F%AA%E8%83%BD%E4%BB%A5%E5%85%B3%E9%94%AE%E5%AD%97%E6%8C%87%E5%AE%9A%E5%92%8C%E5%8F%AA%E8%83%BD%E6%8C%89%E4%BD%8D%E7%BD%AE%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E6%B8%85%E6%99%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8functools-wraps%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">3.8.</span> <span class="toc-text">用functools.wraps定义函数修饰器</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/13/LSTM-CRF/" title="LSTM-CRF">LSTM-CRF</a><time datetime="2023-04-13T08:39:51.000Z" title="发表于 2023-04-13 16:39:51">2023-04-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/el-form%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%BA%8C%E9%80%89%E4%B8%80%E5%BF%85%E5%A1%AB/" title="el-form表单验证二选一必填">el-form表单验证二选一必填</a><time datetime="2023-04-11T12:06:28.000Z" title="发表于 2023-04-11 20:06:28">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/07/effective-python/" title="effective-python">effective-python</a><time datetime="2023-04-07T02:21:34.000Z" title="发表于 2023-04-07 10:21:34">2023-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/11/matplotlib%E5%AD%A6%E4%B9%A0/" title="matplotlib学习">matplotlib学习</a><time datetime="2023-03-11T07:26:46.000Z" title="发表于 2023-03-11 15:26:46">2023-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/09/Numpy%E5%AD%A6%E4%B9%A0/" title="Numpy学习">Numpy学习</a><time datetime="2023-03-09T06:25:13.000Z" title="发表于 2023-03-09 14:25:13">2023-03-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Endercad</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>