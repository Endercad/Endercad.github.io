<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>effective-python | 菜鸟的学习笔记</title><meta name="author" content="Endercad"><meta name="copyright" content="Endercad"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Pythonic思维PEP 8规范《Python Enhancement Proposal #8》又叫PEP 8，是针对Python代码格式而编订的风格指南。PEP 8网址. 应该绝对遵守的规则空白 使用space（空格）来表示缩进，不要用tab 和语法相关的每一层缩进都用4个空格表示 每行的字符数不应超过79 对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常缩进的级别之上再加4个空">
<meta property="og:type" content="article">
<meta property="og:title" content="effective-python">
<meta property="og:url" content="http://example.com/2023/04/07/effective-python/index.html">
<meta property="og:site_name" content="菜鸟的学习笔记">
<meta property="og:description" content="Pythonic思维PEP 8规范《Python Enhancement Proposal #8》又叫PEP 8，是针对Python代码格式而编订的风格指南。PEP 8网址. 应该绝对遵守的规则空白 使用space（空格）来表示缩进，不要用tab 和语法相关的每一层缩进都用4个空格表示 每行的字符数不应超过79 对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常缩进的级别之上再加4个空">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-07T02:21:34.000Z">
<meta property="article:modified_time" content="2023-04-11T06:25:43.904Z">
<meta property="article:author" content="Endercad">
<meta property="article:tag" content="effective python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/07/effective-python/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'effective-python',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-11 14:25:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="菜鸟的学习笔记"><span class="site-name">菜鸟的学习笔记</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">effective-python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-07T02:21:34.000Z" title="发表于 2023-04-07 10:21:34">2023-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-11T06:25:43.904Z" title="更新于 2023-04-11 14:25:43">2023-04-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="effective-python"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Pythonic思维"><a href="#Pythonic思维" class="headerlink" title="Pythonic思维"></a>Pythonic思维</h1><h2 id="PEP-8规范"><a href="#PEP-8规范" class="headerlink" title="PEP 8规范"></a>PEP 8规范</h2><p>《Python Enhancement Proposal #8》又叫PEP 8，是针对Python代码格式而编订的风格指南。<a target="_blank" rel="noopener" href="http://www.python.org/dev/peps/pep-0008">PEP 8网址</a>.</p>
<h3 id="应该绝对遵守的规则"><a href="#应该绝对遵守的规则" class="headerlink" title="应该绝对遵守的规则"></a>应该绝对遵守的规则</h3><h4 id="空白"><a href="#空白" class="headerlink" title="空白"></a>空白</h4><ul>
<li>使用space（空格）来表示缩进，不要用tab</li>
<li>和语法相关的每一层缩进都用<strong>4个</strong>空格表示</li>
<li>每行的字符数不应超过79</li>
<li>对于占据多行的长表达式来说，除了首行之外的其余各行都应该在通常缩进的级别之上<strong>再加4个</strong>空格</li>
<li>文件中的函数于类之间应该用<strong>两个空行</strong>隔开</li>
<li>在同一个类中，各方法之间应该用<strong>一个空行</strong>隔开</li>
<li>在使用下标获取列表元素、调用函数或给关键字参数赋值的时候，不要在两旁添加空格</li>
<li>为变量赋值的时候，赋值符号的<strong>左侧和右侧应该写上一个空格</strong></li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li><strong>函数、变量及属性</strong>应该用<strong>小写字母</strong>来拼写，各单词之间以下划线相连，例如，lowercase_underscore</li>
<li>受保护的实例属性，应该以单个下划线开头,例如，_leading_underscore</li>
<li>私有的实例属性，应该以两个下划线开头，例如，__double_leading_underscore</li>
<li>类与异常，应该以每个单词首字母均大写的形式来命名，例如，CapitalizedWorld</li>
<li>模块级别的常量，应该全部采用大写字母来拼写，各单词之间以下划线相连，例如，ALL_CAPS</li>
<li>类中的实例方法（instance method），应该把首个参数命名为self，以表示该对象自身。</li>
<li>类方法（class method）的首个参数，应该命名为cls，以表示该类自身</li>
</ul>
<h4 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h4><ul>
<li>采用内联形式的否定词，而不要把否定词放在整个表达式的前面，例如，应该写 if a is not b 而不是 if not a is b.</li>
<li>不要通过检测长度的办法(如 if len(somelist) &#x3D;&#x3D; 0)来判断some list是否为[]或’’等空值，而是应该采用if not somelist 这种写法来判断，空值将自动评估为False</li>
<li>检测somelist是否为[1]或’hi’等非空值时，也应该如此，if somelist语句默认会把非空值判断为True</li>
<li>不要编写单行的if语句、for循环、while循环及except复合语句，而是应该把这些语句分成多行来书写，以示清晰</li>
<li>如果表达式一行写不下，可以用括号将其括起来，而且要适当地添加换行与缩进以便于阅读。</li>
<li>多行的表达式，应该用括号括起来，而不要用\符号续行。</li>
</ul>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><ul>
<li>import语句总是应该放在文件开头</li>
<li>引入模块的时候，总是应该使用绝对名称，而不应该根据当前模块的路径来使用相对名称，例如，引入bar包中的foo模块时，应该完整地写出<code>from bar import foo</code> 而不应该简写为<code>import foo</code></li>
<li>如果一定要以相对名称来编写import语句，那就采用明确的写法:<code>from . import foo</code></li>
<li>文件中的那些import 语句应该按顺序分成三个部分，分别表示标准库模块、第三方模块以及自用模块。在每一部分之中，各import语句应该按模块的字母顺序来排列</li>
</ul>
<h2 id="用支持插值的f-string取代C风格的格式字符串与str-format方法"><a href="#用支持插值的f-string取代C风格的格式字符串与str-format方法" class="headerlink" title="用支持插值的f-string取代C风格的格式字符串与str.format方法"></a>用支持插值的f-string取代C风格的格式字符串与str.format方法</h2><p>格式化（formatting）是指把数据填写到预先定义的文本模板里面，形成一条用户可读的消息，并把这条消息保存成字符串的过程。</p>
<h3 id="格式化操作符"><a href="#格式化操作符" class="headerlink" title="%格式化操作符"></a>%格式化操作符</h3><p>Python里面最常用的字符串格式化方式是采用%格式化操作符。这个操作符左边的文本模板叫作格式字符串（format string），我们可以在操作符右边写上某个值或者由多个值所构成的元组（tuple），用来替换格式字符串里的相关符号。例如，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;world&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;python&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello %s,hello %s&#x27;</span> % (a,b))</span><br><span class="line"></span><br><span class="line"><span class="comment">## output:hello world,hello python</span></span><br></pre></td></tr></table></figure>

<p>格式字符串里面可以出现%d这样的格式说明符，这些说明符的意思是，%右边的对应数值会以这样的格式来替换这一部分内容。格式说明符的写法来自C语言的printf函数，Python语言以及其他一些编程语言，都依照那套写法来规定自己的格式字符串。所以，常见的printf选项都可以当成Python的格式说明符来用，例如%s、%x、%f等，此外还可以控制小数点的位值，并指定填充与对齐方式。</p>
<p>C风格的格式字符串，在Python里有四个缺点。</p>
<ul>
<li>第一个缺点是，如果%右侧那个元组里面的值在类型或顺序上有变化，那么程序可能会因为转换类型时发生不兼容问题而出现错误。</li>
<li>第二个缺点是，在填充模板之前，经常要先对准备填写进去的这个值稍微做一些处理，但这样一来，整个表达式可能就会写得很长，让人觉得比较混乱。</li>
<li>第三个缺点是，如果想用同一个值来填充格式字符串里的多个位置，那么必须在%操作符右侧的元组中相应地多次重复该值。</li>
<li>第四个缺点是，把dict写到格式化表达式里面会让代码变多。每个键都至少要写两次：一次是在格式说明符中，还有一次是在字典中作为键，另外，定义字典的时候，可能还要专门用一个变量来表示这个键所对应的值，而且这个变量的名称或许也和键名相同，这样算下来就是三次了。</li>
</ul>
<h3 id="内置的format函数与str类的format方法"><a href="#内置的format函数与str类的format方法" class="headerlink" title="内置的format函数与str类的format方法"></a>内置的format函数与str类的format方法</h3><p>Python 3添加了高级字符串格式化（advanced string formatting）机制，它的表达能力比老式C风格的格式字符串要强，且不再使用%操作符。我们针对需要调整格式的这个Python值，调用内置的format函数，并把这个值所应具备的格式也传给该函数，即可实现格式化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1234.5678</span></span><br><span class="line">formatted=<span class="built_in">format</span>(a,<span class="string">&#x27;,.2f&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(formatted)</span><br><span class="line"><span class="comment">#output:1,234.57</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">formatted=<span class="built_in">format</span>(b,<span class="string">&#x27;^20s&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span>,formatted,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="comment">#output:*        hello         *</span></span><br></pre></td></tr></table></figure>

<p>在传给format函数的格式里面，逗号表示显示千位分隔符，^表示居中对齐。</p>
<p>如果str类型的字符串里面有许多值都需要调整格式，则可以调用str的新format方法。该方法不使用%d这样的C风格格式说明符。而是把格式有待调整的那些位置在字符串里面先用{}代替，然后按从左到右的顺序，把需要填写到那些位置的值传给format方法，使这些值依次出现在字符串中的相应位置。</p>
<p>可以在{}里写个冒号，然后把格式说明符写在冒号的右边，用以规定format方法所接收的这个值应该按照怎样的格式来调整.调用str.format方法的时候，也可以给str的{}里面写上数字，用来指代format方法在这个位置所接收到的参数值位置索引。同一个位置索引可以出现在str的多个{}里面，这些{}指代的都是format方法在对应位置所收到的值。</p>
<p>但是str.format无法解决上面所说的第二个与第四个缺点</p>
<h3 id="插值格式字符串"><a href="#插值格式字符串" class="headerlink" title="插值格式字符串"></a>插值格式字符串</h3><p>Python 3.6添加了一种新的特性，叫作插值格式字符串（interpolated format string，简称f-string），可以解决上面提到的所有问题。新语法特性要求在格式字符串的前面加字母f作为前缀，这跟字母b与字母r的用法类似，也就是分别表示字节形式的字符串与原始的（或者说未经转义的）字符串的前缀。</p>
<p>可以直接在f-string的{}里面引用当前Python范围内的所有名称，进而达到简化的目的。彻底解决了上文提到的第四个缺点，也就是键名重复导致的程序冗余问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key=<span class="string">&#x27;var&#x27;</span></span><br><span class="line">val=<span class="number">123.4</span></span><br><span class="line">formatted=<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;val&#125;</span>&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(formatted)</span><br><span class="line"><span class="comment">#output var=123.4</span></span><br></pre></td></tr></table></figure>

<p>str.format方法所支持的那套迷你语言，也就是在{}内的冒号右侧所采用的那套规则，现在也可以用到f-string里面，而且还可以像早前使用str.format时那样，通过!符号把值转化成Unicode及repr形式的字符串。</p>
<h2 id="用辅助函数取代复杂的表达式"><a href="#用辅助函数取代复杂的表达式" class="headerlink" title="用辅助函数取代复杂的表达式"></a>用辅助函数取代复杂的表达式</h2><p>当表达式过长的时候，可以用if&#x2F;else结构实现三元的条件表达式，但这种写法不如完整的多行if&#x2F;else结构清晰，如果要反复使用这套逻辑，最好的方法是写成辅助函数</p>
<h2 id="尽量用enumerate取代range"><a href="#尽量用enumerate取代range" class="headerlink" title="尽量用enumerate取代range"></a>尽量用enumerate取代range</h2><p>Python内置的range函数适合用来迭代一系列整数。如果要迭代的是某种数据结构，例如字符串列表，那么可以直接在这个序列上面迭代，用不着专门通过range设定一个取值范围，然后把这个范围里的每个整数值，依次当成下标来访问列表中的元素。</p>
<p>当有时候需要知道元素在list中的位置时，为了实现这样的功能，可以使用range实现。但这样的方法需要知道列表的长度，步骤太多。</p>
<p>Python有个内置的函数，叫作enumerate，它可以解决刚才的问题。enumerate能够把任何一种迭代器（iterator）封装成惰性生成器。这样的话，每次循环的时候，它只需要从iterator里面获取下一个值就行了，同时还会给出本轮循环的序号，即生成器每次产生的一对输出值。可以通过enumerate的第二个参数指定起始序号，这样就不用在每次打印的时候去调整了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">snacks=[<span class="string">&#x27;bacon&#x27;</span>,<span class="string">&#x27;hamburger&#x27;</span>,<span class="string">&#x27;ice-cream&#x27;</span>]</span><br><span class="line">it=<span class="built_in">enumerate</span>(snacks,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="comment">## output:</span></span><br><span class="line"><span class="comment"># (1, &#x27;bacon&#x27;)</span></span><br><span class="line"><span class="comment"># (2, &#x27;hamburger&#x27;)</span></span><br><span class="line"><span class="comment"># (3, &#x27;ice-cream&#x27;)</span></span><br></pre></td></tr></table></figure>

<h2 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h2><p>如果两个列表对应位置的元素有着一定的关系，并且需要同时遍历这两个列表，一种方法是使用range对列表长度做迭代</p>
<p>为了把代码写得更清楚，可以用Python内置的zip函数来实现。这个函数能把两个或更多的iterator封装成惰性生成器（lazy generator）。每次循环时，它会分别从这些迭代器里获取各自的下一个元素，并把这些值放在一个元组里面。而这个元组可以拆分到for语句里的那些变量之中。这样写出来的代码，比通过下标访问多个列表的那种代码要清晰得多。</p>
<p>zip每次只从它封装的那些迭代器里面各自取出一个元素，所以即便源列表很长，程序也不会因为占用内存过多而崩溃。</p>
<p>但是，如果zip中列表的长度不一致，zip在处理完其中任何一个迭代器之后就不会再往下，循环的次数实际上等于最短的那个列表所具备的长度。</p>
<h2 id="用赋值表达式"><a href="#用赋值表达式" class="headerlink" title="用赋值表达式"></a>用赋值表达式</h2><p>赋值表达式（assignment expression）是Python 3.8新引入的语法，它会用到海象操作符（walrus operator）。这种写法可以解决某些持续已久的代码重复问题。a &#x3D; b是一条普通的赋值语句，读作a equals b，而<strong>a :&#x3D; b则是赋值表达式</strong>，读作a walrus b。这个符号为什么叫walrus呢？因为把:&#x3D;顺时针旋转90º之后，冒号就是海象的一双眼睛，等号就是它的一对獠牙。</p>
<p>赋值表达式可以再普通的赋值语句无法应用的场合使用，例如在条件表达式的if语句中，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 常规写法</span></span><br><span class="line">count = get_lemon_num()</span><br><span class="line"><span class="keyword">if</span> count:</span><br><span class="line">    make_lemonade(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    out_of_stock()</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 赋值表达式写法</span></span><br><span class="line"><span class="keyword">if</span> count := get_lemon_num():</span><br><span class="line">    make_lemonade(count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    out_of_stock()</span><br></pre></td></tr></table></figure>

<p>在python中实现switch&#x2F;case的一种方法是嵌套if&#x2F;elif&#x2F;else结构。在使用海象操作符时，可以轻松模拟很接近switch&#x2F;case的方案</p>
<h1 id="列表与字典"><a href="#列表与字典" class="headerlink" title="列表与字典"></a>列表与字典</h1><h2 id="通过带星号的unpacking操作来捕获多个元素，不要用切片"><a href="#通过带星号的unpacking操作来捕获多个元素，不要用切片" class="headerlink" title="通过带星号的unpacking操作来捕获多个元素，不要用切片"></a>通过带星号的unpacking操作来捕获多个元素，不要用切片</h2><p>带星号的表达式也是一种unpacking操作，它可以把无法由普通变量接收的那些元素全部囊括进去。带星号的表达式可以出现在任意位置，所以它能够捕获序列中的任何一段元素。但是在使用这种写法时，至少要有一个普通的接收变量与它搭配，另外，对于单层结构来说，同一级里至多只能出现一次带星号的unpacking。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">smallest,second_small,*others=nums</span><br><span class="line">smallest,second_small,others</span><br><span class="line"><span class="comment">#output:(1, 2, [3, 4, 5, 6, 7])</span></span><br><span class="line">smallest,*others,biggest=nums</span><br><span class="line">smallest,others,biggest</span><br><span class="line"><span class="comment">#output:(1, [2, 3, 4, 5, 6], 7)</span></span><br></pre></td></tr></table></figure>

<h2 id="用sort方法的key参数来表示复杂的排序逻辑"><a href="#用sort方法的key参数来表示复杂的排序逻辑" class="headerlink" title="用sort方法的key参数来表示复杂的排序逻辑"></a>用sort方法的key参数来表示复杂的排序逻辑</h2><p>凡是具备自然顺序的内置类型几乎都可以用sort方法排列，例如字符串、浮点数等。但是对于对象，这些排序标准通常是针对对象中的某个属性（attribute）。我们可以把这样的排序逻辑定义成函数，然后将这个函数传给sort方法的key参数。key所表示的函数本身应该带有一个参数，这个参数指代列表中有待排序的对象，函数返回的应该是个可比较的值（也就是具备自然顺序的值），以便sort方法以该值为标准给这些对象排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,weigth</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.weight=weigth</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;Tool(<span class="subst">&#123;self.name&#125;</span>,<span class="subst">&#123;self.weight&#125;</span>)&#x27;</span></span><br><span class="line">tools=[</span><br><span class="line">    Tool(<span class="string">&#x27;level&#x27;</span>,<span class="number">3.5</span>),</span><br><span class="line">    Tool(<span class="string">&#x27;hammer&#x27;</span>,<span class="number">1.25</span>),</span><br><span class="line">    Tool(<span class="string">&#x27;screwdriver&#x27;</span>,<span class="number">0.5</span>),</span><br><span class="line">    Tool(<span class="string">&#x27;chisel&#x27;</span>,<span class="number">0.25</span>)</span><br><span class="line">]</span><br><span class="line">tools.sort(key=<span class="keyword">lambda</span> x:x.name)</span><br><span class="line">tools</span><br><span class="line"><span class="comment">#output:[Tool(chisel,0.25), Tool(hammer,1.25), Tool(level,3.5), Tool(screwdriver,0.5)]</span></span><br></pre></td></tr></table></figure>

<p>在编写传给key参数的lambda函数时，可以像刚才那样返回对象的某个属性，如果对象是序列、元组或字典，那么还可以返回其中的某个元素。其实，只要是有效的表达式，都可以充当lambda函数的返回值。sort方法可以指定reverse参数实现降序排序</p>
<h2 id="用get处理键不在字典中的情况，不要使用in与KeyError"><a href="#用get处理键不在字典中的情况，不要使用in与KeyError" class="headerlink" title="用get处理键不在字典中的情况，不要使用in与KeyError"></a>用get处理键不在字典中的情况，不要使用in与KeyError</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fruits=&#123;<span class="string">&#x27;apple&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;orange&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># 判断是否含有apple这个属性</span></span><br><span class="line">key=<span class="string">&#x27;apple&#x27;</span></span><br><span class="line"><span class="comment"># 使用in来判断</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> fruits:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># 利用keyError异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    count=fruits[key]</span><br><span class="line"><span class="keyword">except</span> keyError:</span><br><span class="line">    ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>获取字典中存在的键，或给字典中不存在的键指定默认值，这两种操作非常常见。所以，Python内置的字典（dict）类型提供了get方法，可以通过第一个参数指定自己想查的键，并通过第二个参数指定这个键不存在时应返回的默认值。这种写法也只需要在查询键值时访问一次键名，然后做一次赋值操作，但要比刚才那种通过KeyError实现的方案简单得多。</p>
<p>dict类型提供了setdefault方法，这个方法会查询字典里有没有这个键，如果有，就返回对应的值；如果没有，就先把用户提供的默认值跟这个键关联起来并插入字典，然后返回这个值.</p>
<p>还有个关键的地方要注意：在字典里面没有这个键时，setdefault方法会把默认值直接放到字典里，而不是先给它做副本，然后把副本放到字典中</p>
<h2 id="用defaultdict处理内部状态中缺失的元素，而不要用setdefault"><a href="#用defaultdict处理内部状态中缺失的元素，而不要用setdefault" class="headerlink" title="用defaultdict处理内部状态中缺失的元素，而不要用setdefault"></a>用defaultdict处理内部状态中缺失的元素，而不要用setdefault</h2><p>Python内置的collections模块提供了defaultdict类,它会在键缺失的情况下，自动添加这个键以及键所对应的默认值。当使用defaultdict创建字典时，访问一个不存在的键，会自动添加这个键以及键所对应的默认值。</p>
<h2 id="学会利用-missing-构造依赖键的默认值"><a href="#学会利用-missing-构造依赖键的默认值" class="headerlink" title="学会利用__missing__构造依赖键的默认值"></a>学会利用__missing__构造依赖键的默认值</h2><p>通过继承dict类型并实现<code>__missing__</code>特殊方法可以在字典不存在这个键时执行我们自定义的逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self,key</span>):</span><br><span class="line">        value = open_picture(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">pictures=Picture()</span><br><span class="line">handle=pictures[path]</span><br><span class="line">handle.seek(<span class="number">0</span>)</span><br><span class="line">image_data=handle.read()</span><br></pre></td></tr></table></figure>

<p>访问pictures[path]时，如果pictures字典里没有path这个键，那就会调用__missing__方法。这个方法必须根据key参数创建一份新的默认值，系统会把这个默认值插入字典并返回给调用方。以后再访问pictures[path]，就不会调用__missing__了，因为字典里已经有了对应的键与值</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="不要把函数返回的多个数值拆分到三个以上的变量中"><a href="#不要把函数返回的多个数值拆分到三个以上的变量中" class="headerlink" title="不要把函数返回的多个数值拆分到三个以上的变量中"></a>不要把函数返回的多个数值拆分到三个以上的变量中</h2><p>不应该把函数返回的多个值拆分到三个以上的变量里。一个三元组最多只拆成三个普通变量，或两个普通变量与一个万能变量（带星号的变量）。当然用于接收的变量个数也可以比这更少。假如要拆分的值确实很多，那最好还是定义一个轻便的类或namedtuple，并让函数返回这样的实例。</p>
<h2 id="遇到意外状况时应该抛出异常，不要返回None"><a href="#遇到意外状况时应该抛出异常，不要返回None" class="headerlink" title="遇到意外状况时应该抛出异常，不要返回None"></a>遇到意外状况时应该抛出异常，不要返回None</h2><p>在if语句中，可能会无法明确区分0和None，因此用None表示特殊状况的函数很容易出错，解决这种错误的方法时抛出异常，让调用方去处理。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Endercad</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/07/effective-python/">http://example.com/2023/04/07/effective-python/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">菜鸟的学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/effective-python/">effective python</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/11/el-form%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%BA%8C%E9%80%89%E4%B8%80%E5%BF%85%E5%A1%AB/" title="el-form表单验证二选一必填"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">el-form表单验证二选一必填</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/11/matplotlib%E5%AD%A6%E4%B9%A0/" title="matplotlib学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">matplotlib学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Endercad</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/endercad"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">要比昨天的自己更好</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Pythonic%E6%80%9D%E7%BB%B4"><span class="toc-number">1.</span> <span class="toc-text">Pythonic思维</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PEP-8%E8%A7%84%E8%8C%83"><span class="toc-number">1.1.</span> <span class="toc-text">PEP 8规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E7%BB%9D%E5%AF%B9%E9%81%B5%E5%AE%88%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">应该绝对遵守的规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%99%BD"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">空白</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">表达式和语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">引入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%94%AF%E6%8C%81%E6%8F%92%E5%80%BC%E7%9A%84f-string%E5%8F%96%E4%BB%A3C%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Estr-format%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">用支持插值的f-string取代C风格的格式字符串与str.format方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">%格式化操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84format%E5%87%BD%E6%95%B0%E4%B8%8Estr%E7%B1%BB%E7%9A%84format%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">内置的format函数与str类的format方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.</span> <span class="toc-text">插值格式字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">用辅助函数取代复杂的表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E7%94%A8enumerate%E5%8F%96%E4%BB%A3range"><span class="toc-number">1.4.</span> <span class="toc-text">尽量用enumerate取代range</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8zip%E5%87%BD%E6%95%B0%E5%90%8C%E6%97%B6%E9%81%8D%E5%8E%86%E4%B8%A4%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">用zip函数同时遍历两个迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">用赋值表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E4%B8%8E%E5%AD%97%E5%85%B8"><span class="toc-number">2.</span> <span class="toc-text">列表与字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%B8%A6%E6%98%9F%E5%8F%B7%E7%9A%84unpacking%E6%93%8D%E4%BD%9C%E6%9D%A5%E6%8D%95%E8%8E%B7%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8%E5%88%87%E7%89%87"><span class="toc-number">2.1.</span> <span class="toc-text">通过带星号的unpacking操作来捕获多个元素，不要用切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8sort%E6%96%B9%E6%B3%95%E7%9A%84key%E5%8F%82%E6%95%B0%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8E%92%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-number">2.2.</span> <span class="toc-text">用sort方法的key参数来表示复杂的排序逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8get%E5%A4%84%E7%90%86%E9%94%AE%E4%B8%8D%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8in%E4%B8%8EKeyError"><span class="toc-number">2.3.</span> <span class="toc-text">用get处理键不在字典中的情况，不要使用in与KeyError</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8defaultdict%E5%A4%84%E7%90%86%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%A6%81%E7%94%A8setdefault"><span class="toc-number">2.4.</span> <span class="toc-text">用defaultdict处理内部状态中缺失的元素，而不要用setdefault</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%BC%9A%E5%88%A9%E7%94%A8-missing-%E6%9E%84%E9%80%A0%E4%BE%9D%E8%B5%96%E9%94%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">2.5.</span> <span class="toc-text">学会利用__missing__构造依赖键的默认值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E6%8A%8A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%95%B0%E5%80%BC%E6%8B%86%E5%88%86%E5%88%B0%E4%B8%89%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="toc-number">3.1.</span> <span class="toc-text">不要把函数返回的多个数值拆分到三个以上的变量中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E6%84%8F%E5%A4%96%E7%8A%B6%E5%86%B5%E6%97%B6%E5%BA%94%E8%AF%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9ENone"><span class="toc-number">3.2.</span> <span class="toc-text">遇到意外状况时应该抛出异常，不要返回None</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/11/el-form%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%BA%8C%E9%80%89%E4%B8%80%E5%BF%85%E5%A1%AB/" title="el-form表单验证二选一必填">el-form表单验证二选一必填</a><time datetime="2023-04-11T12:06:28.000Z" title="发表于 2023-04-11 20:06:28">2023-04-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/07/effective-python/" title="effective-python">effective-python</a><time datetime="2023-04-07T02:21:34.000Z" title="发表于 2023-04-07 10:21:34">2023-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/11/matplotlib%E5%AD%A6%E4%B9%A0/" title="matplotlib学习">matplotlib学习</a><time datetime="2023-03-11T07:26:46.000Z" title="发表于 2023-03-11 15:26:46">2023-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/09/Numpy%E5%AD%A6%E4%B9%A0/" title="Numpy学习">Numpy学习</a><time datetime="2023-03-09T06:25:13.000Z" title="发表于 2023-03-09 14:25:13">2023-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86/" title="深度学习零散知识">深度学习零散知识</a><time datetime="2023-02-23T14:46:13.000Z" title="发表于 2023-02-23 22:46:13">2023-02-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Endercad</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>